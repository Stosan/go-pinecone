syntax = "proto3";
import "google/protobuf/timestamp.proto";

package core;
option java_package = "io.pinecone.proto";
option go_package = "github.com/pinecone-io/go-pinecone/pinecone";




/**
   Request from the controller to individual service for monitoring, updating, and terminating running services.
 */
message ServiceControlRequest {
    string function = 1; // Name of the function.

    uint64 function_id = 2; // Unique id of the function (if any).

    Status status = 3; // Status of the function.

    string service = 4; // Name of the service the function belongs to.
}

/**
 * Represents the a numpy ndarray
 */
message NdArray {
    // the actual array data, in bytes
    bytes buffer = 1;

    // the shape (dimensions) of the array
    repeated uint32 shape = 2;

    // the data type of the array
    string dtype = 3;

    // whether lz4 compression is used on buffer
    bool compressed = 4;
}

/**
* Represents the route paths of this message
 */
message Route {
    string function = 1; // the name of the Service
    int32 function_id = 2; // the id of the Service
    google.protobuf.Timestamp start_time = 3; // receiving time
    google.protobuf.Timestamp end_time = 4; // sending (out) time
}

/**
 * Represents an execution plane Request
 */
message Request {

    // unique id of the request
    uint64 request_id = 1;

    // timeout in second until this message is dropped
    uint32 timeout = 2;

    // path in DAG (defined ahead of time) to follow
    string path = 3;

    // request schema version
    string version = 4;

    repeated Route routes = 5; // a list of routes this message goes through

    Status status = 6; // status info, e.g. error

    oneof body {
        QueryRequest query = 7; // A query request object
        IndexRequest index = 8; // An upsert items request object
        DeleteRequest delete = 9; // A delete items request object
        InfoRequest info = 10; // An object for a get info request
        FetchRequest fetch = 11; // Payload for a request to fetch vectors by id
        ListRequest list = 12; // Payload for a request to list resource in the index

    }

    string namespace = 13; // Namespace to perform operation in (if data is divided by namespace, default "")

    uint32 client_id = 14; // Integer ID that represents the client connection. Assigned by gateway.

    uint32 client_offset = 15; // Offset of request within client connection. Assigned by gateway.

    uint32 shard_num = 16; // Shard the message came from. Used by aggregator

    uint32 gateway_num = 17; // Tail of gateway

     /**
       For tracing only
      */
    uint64 telemetry_trace_id = 18;

    uint64 telemetry_parent_id = 19;

    string service_name = 20;

    bool traceroute = 21; // Send receipts from every function back to the gateway in case the DAG fails

    uint32 num_shards = 22;
}

message Status {

    enum StatusCode {
        SUCCESS = 0; // success
        READY = 1; // ready to use
        ERROR = 2; // error
        ERROR_DUPLICATE = 3; // already a existing service
    }

    // status code
    StatusCode code = 1;

    // error description of the very first exception
    string description = 2;

    message Details {
        // the name of that problematic service
        string function = 1;

        // the id of that problematic service
        string function_id = 2;

        // the class name of the exception
        string exception = 3;

        // the reason of the exception
        string traceback = 4;

        // the timestamp when error occurs
        google.protobuf.Timestamp time = 5;
    }

    // the details of the error
    repeated Details details = 3;

    // number of messages sent by the function
    uint64 msg_sent = 4;

    // number of messages received by the function
    uint64 msg_recv = 5;

    // average time spent by messages in function
    map<string, uint32> avg_time = 6;

    // size of a function's dataset if stateful
    uint64 size = 7;
}


message ScoredResults {
    // String ids of the item results of a query
    NdArray ids = 1;

    // Corresponding pairwise scores between the query to each item
    NdArray scores = 2;

    // Corresponding data for all of these items, if requested
    NdArray data = 3;

    // Corresponding metadata for all of these items, if requested
    NdArray metadata = 4;
}

/**
 * Represents an index request
 */
message IndexRequest {
    // ids of items to be inserted
    repeated string ids = 1;

    // vectors of items to be inserted
    NdArray data = 2;
    
    // metadata of items to be inserted
    repeated string metadata = 3;
}

/**
 * Represents a query request
 */
message QueryRequest {
    uint32 top_k = 1; // Number of results to return for each query
    bool include_data = 2; // Whether to include the vectors and raw data in response as well as ids
    NdArray data = 3; // The batch of vectors to query
    repeated ScoredResults matches = 4; // The corresponding matches returned for each query in the batch
    repeated uint32 top_k_overrides = 5;
    repeated string namespace_overrides = 6;
    string filter = 7;
    repeated string filter_overrides = 8;
    bool include_metadata = 9; // Whether to include metadata in response as well as ids

}

/**
 * Represents a delete request
 */
message DeleteRequest {
    repeated string ids = 1; // Ids of items to delete
    bool delete_all = 2; // Delete all ids
}

/**
 * Represents an info request
 */
message InfoRequest {
    uint64 index_size = 1; // Size of a stateful function (Index)
    uint32 dimension = 2; // Dimension of the indexed vectors
}

/**
 * Represents a fetch request
 */
message FetchRequest {
    repeated string ids = 1; // Ids of vectors to fetch
    repeated NdArray vectors = 2; // Result vectors corresponding to ids
    repeated string metadata = 3; // Result metadata corresponding to ids
}

/**
 * Represents a fetch request
 */
message ListRequest {
    string resource_type = 1; // e.g. 'ids', 'namespace', etc.
    NdArray items = 2;
}


/**
 * An acknowledgement from a replica to the leader that it has caught up to that point in the log.
 */
message Ack {
    uint32 replica = 1; // Ordinal of replica the request comes from
    bool replay = 2; // Whether the replica is requesting a replay starting from acked offset
}

message LogEntry {
    int64 offset = 1; // WAL offset of this entry
    oneof data {
        Request entry = 2; // The request itself as it was received
        Ack ack = 3; // Or an acknowledgement from a follower of receiving this entry
    }
    // The offset of the previous WAL entry. This is not necessarily (offset-1) due to the way log compaction works.
    int64 previous_offset = 4;
}

/* Represents an entry written into a WAL like Kafka. Provides an envelope for storing multiple types of message
 * (https://www.enterpriseintegrationpatterns.com/patterns/messaging/EnvelopeWrapper.html).
 *
 * Contents can be related to data or control.
 *
 * Data Entries: Examples are requests to upsert or delete data from the index.
 * Control Entries: Examples are requests to partition the snapshot, etc.
 */
message WriteAheadLogEntry {
    // A string identifying the origin of the message. This is used for trouble-shooting / diagnostics.
    oneof contents {
        WriteAheadLogDataEntry data = 1;
    }
}

message WriteAheadLogDataEntry {
    oneof entry {
        // Request is API level modelling and we should decouple it from the stuff we put in the log. However, this
        // seems  to be the fastest way to get something working at the moment.
        // TODO: Deprecate
        Request request = 1;
    }
}

/**
 * Receipts sent back to gateway from each function if "traceroute" flag is set
 */
message TraceRoute {
    uint64 request_id = 1;

    uint32 client_id = 2;

    uint32 client_offset = 3;

    repeated Route routes = 4;
}

/**
 * Signal to snapshotter that the index is ready to be distributed to replicas
 */
message SnapshotRequest {
    google.protobuf.Timestamp time = 1;
    string name = 2;
}

/**
 * Response to snapshot request
 */
message SnapshotResponse {
    google.protobuf.Timestamp time = 1;
}

/**
 * Snapshot client
 */
service SnapshotClient {
    rpc Call (SnapshotRequest) returns (SnapshotResponse) {

    }
}

/**
 * core gRPC service.
 */
service RPCClient {
    // Pass in a Request stream and completed Requests will be returned
    rpc Call (stream Request) returns (stream Request) {

    }

    // Pass in a single request, and a completed request will be returned
    rpc CallUnary (Request) returns (Request) {

    }
}


